# nezcc file

extension          = scala

# type

Bool               = Boolean
Byte               = Byte
Int                = Int
String             = String
Array              = Array[%s]
Int64              = Long
Tree               = T

Byte->Int          = %s & 0xff
Int64->Int         = (%s).toInt
String->Byte[]     = (%s).getBytes("UTF-8")
String.+0          = (%s + "\0")

# If 32bit-length integer exists, 
Int32             = Int

#java
#base64           = B("%s")
#bools            = B256("%s")

structname         = %s[T]

Array.size        = %s.length
Array.get         = %s(%s)
Array.new         = new Array[%s](%s)

Byte[].slice      = %s.slice(%s, %s)


Option             = Option[%s]
Some               = Some(%s)
None               = None
Option.get         = %s.get
Option.isNone      = %s.isEmpty

# syntax

comment          = // %s
begin            = {
end              = }
;                = 

module           = object $|base| {

struct           = class %s[T](%s) {
record           = var %2$s: %1$s
records          = ,
new              = new %s

functype         = (%3$s) => %1$s
functypeparam    = %1$s

const            = private val %2$s: %1$s = %3$s

#function         = private val %2$s = (%3$s) => {
function         = private def %2$s[T](%3$s): %1$s = {
param            = %2$s: %1$s
#return           = %s

#cast             = (%s)(%s)

//apply            = %s
funcref          = (p: NezParserContext[T]) => %s(p)

if               = if(%s) {
else if          = else if(%s) {
while            = while(%s) {
switch           = %s match {
case             = case %s => %s
default          = case _ => %s

lambda           = (%s: NezParserContext[T]) => (%s):Boolean

ifexpr           = (if (%s) %s else %s)

letin            = { val %2$s: %1$s = %3$s; %4$s }
val              = val %2$s: %1$s = %3$s
var              = var %2$s: %1$s = %3$s
assign           = %s = %s

array            = Array(
arrays           = ,
end array        = )

## Default AST

Symbol           = String

AST               = '''
  class SimpleTree(key: $|Symbol|, value: AnyRef) {
    override def toString = if (value.isInstanceOf[SimpleTree]) s"$key: $value" else s"[#$key $value]"
    def set(n: Int, label: $|Symbol|, child: SimpleTree) = {
      value.asInstanceOf[Array[SimpleTree]](n) = new SimpleTree(label, child)
      this
    }
  }
'''

## tag=%1$s, inputs=%2$s, pos=%3$s, epos=%4$s, nsubs=%5$s
AST.new           = new SimpleTree(%1$s, if(%5$s > 0) new Array[SimpleTree](%5$s) else new String(%2$s, %3$s, (%4$s-%3$s)))

## parent=%1$s, n=%2$s, label=%3$s, child=%4$s
AST.set           = %1$s.set(%2$s, %3$s, %4$s)

imports = '''
import java.nio.charset.Charset;
import java.util.Base64;
//import java.util.Objects;
import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
'''

libs = '''
  def B(s: String): Array[Byte] = Base64.getDecoder.decode(s.getBytes)

  def B256(s: String): Array[Boolean] = {
    val b: Array[Boolean] = Array.ofDim[Boolean](256)
    for (i <- 0 until s.length if s.charAt(i) == 'T' || s.charAt(i) == '1') {
      b(i) = true
    }
    b
  }
'''

main = '''
  def readInputs(a: String): String = {
    val file: File = new File(a)
    if (file.exists()) {
      val sb: StringBuilder = new StringBuilder()
      val br: BufferedReader = new BufferedReader(new FileReader(file))
      var str: String = br.readLine()
      while (str != null) {
        sb.append(str)
        sb.append("\n")
        str = br.readLine()
      }
      br.close()
      sb.toString
    }
    else {
      a
    }
  }
      
  def main(args: Array[String]): Unit = {
    for (a <- args) {
      val s: String = readInputs(a)
      val st: Long = System.nanoTime()
      val t: SimpleTree = parseText(s, 
        (tag, inputs, pos, epos, size) => newAST(tag, inputs, pos, epos, size), 
        (parent, n, label, child) => subAST(parent, n, label, child))
      val et: Long = System.nanoTime()
      System.err.printf("%s %s %f[ms]: ", a,
                        if (t != null) "OK" else "NG",
                        (et - st) / 1000000.0)
      print(t)
      System.out.flush
      System.err.printf("\n")
    }
  }
'''

man = '''
=============
 QUICK START
=============
 
 scalac $|base|.java
 scala $|base| <file> or <input-text>
 
=============
 INTEGRATION
=============

Just call $|base|.parse() like below. You will get
a simple tree representation ($|base|.SimpleTree).

   SimpleTree t = $|base|.parse("sometext");
   if(t != null) {
      System.out.println(t);
   }
'''

